Inox String Interpolation
=========================

[//]: # (The documentation sources are stored in src/main/doc/, while doc/ contains the autogenerated version by `tut`.)

# Table of Content

- ***[Introduction](#introduction)***
  - [Importing](#importing)
- ***[Syntax](#syntax)***
  - [Literals](#literals)
    - [Boolean](#boolean-literals)
    - [Numeric](#numeric-literals)
      - [Real](#real-literals)
    - [String](#string-literals)
    - [Character](#character-literals)
  - [Arithmetic](#arithmetic)
  - [Conditionals](#conditionals)
  - [Let bindings](#let-bindings)
  - [Lambda expressions](#lambda-expressions)
  - [Quantifiers](#quantifiers)
    - [Universal quantifiers](#universal-quantifiers)
  - [Choose](#choose)

- ***[Primitives](#primitives)***
  - [Strings](#primitive-strings)
  - [Sets](#primitive-sets)
  - [Bags](#primitive-bags)
  - [Maps](#primitive-maps)

<a name="introduction"></a>
# Introduction

In this document, we describe the string interpolation facility offered in Inox. String interpolations make it possible to build and deconstruct Inox types and expressions using a succinct and expressive language. Throughout this document, we will describe the syntax of this language and its primitive constructs.

<a name="importing"></a>
## Importing the interpolator

The first step to use this feature is to import it. The string interpolator is located within the `Symbols` class.

```scala
import inox._
import inox.trees._
import inox.trees.interpolator._

implicit val mySymbols = NoSymbols
```

Once imported, it is possible to build Inox types and expressions using a friendlier syntax:

```scala
scala> val tpe = t"Boolean"
tpe: inox.trees.Type = Boolean

scala> val expr = e"1 + 1 == 2"
expr: inox.trees.Expr = 1 + 1 == 2
```

It is also possible to embed types and expressions:

```scala
scala> e"let x: $tpe = $expr in !x"
res1: inox.trees.Expr =
val x: Boolean = 1 + 1 == 2
¬x
```

<a name="syntax"></a>
# Syntax

<a name="literals"></a>
## Literals

<a name="boolean-literals"></a>
### Boolean literals

```scala
scala> e"true"
res2: inox.trees.Expr = true

scala> e"false"
res3: inox.trees.Expr = false
```

<a name="numeric-literals"></a>
### Numeric literal

```scala
scala> e"1"
res4: inox.trees.Expr = 1
```

Note that the type of numeric expressions is inferred. In case of ambiguity, `Integer` is chosen by default.

```scala
scala> val bigIntLit = e"1"
bigIntLit: inox.trees.Expr = 1

scala> bigIntLit.getType
res5: inox.trees.Type = BigInt
```

It is however possible to annotate the desired type.

```scala
scala> val intLit = e"1 as Int"
intLit: inox.trees.Expr = 1

scala> intLit.getType
res6: inox.trees.Type = Int32Type
```

```scala
scala> val realLit = e"1 as Real"
realLit: inox.trees.Expr = 1

scala> realLit.getType
res7: inox.trees.Type = Real
```

<a name="real-literals"></a>
#### Real literals

```scala
scala> e"3.75"
res8: inox.trees.Expr = 15/4
```

<a name="string-literals"></a>
### String literals

```scala
scala> e"'Hello world!'"
res9: inox.trees.Expr = "Hello world!"
```

<a name="character-literals"></a>
### Character literals

```scala
scala> e"`a`"
res10: inox.trees.Expr = 'a'
```

<a name="arithmetic"></a>
## Arithmetic

Arithmetic operators are infix and have there usual associativity and priority.

```scala
scala> e"1 + 2 * 5 + 6 - 7 / 17"
res11: inox.trees.Expr = ((1 + 2 * 5) + 6) - 7 / 17
```

<a name="conditionals"></a>
## Conditionals

```scala
scala> e"if (1 == 2) 'foo' else 'bar'"
res12: inox.trees.Expr =
if (1 == 2) {
  "foo"
} else {
  "bar"
}
```

<a name="let-bindings"></a>
## Let bindings

```scala
scala> e"let word: String = 'World!' in concatenate('Hello ', word)"
res13: inox.trees.Expr =
val word: String = "World!"
"Hello " + word
```

<a name="lambda-expressions"></a>
## Lambda expressions

```scala
scala> e"lambda x: Integer, y: Integer. x + y"
res14: inox.trees.Expr = (x: BigInt, y: BigInt) => x + y
```

It is also possible to use the Unicode `λ` symbol.

```scala
scala> e"λx: Integer, y: Integer. x + y"
res15: inox.trees.Expr = (x: BigInt, y: BigInt) => x + y
```

Type annotations can be omitted for any of the parameters if their type can be inferred.

```scala
scala> e"lambda x. x * 0.5"
res16: inox.trees.Expr = (x: Real) => x * 1/2
```

<a name="quantifiers"></a>
## Quantifiers

<a name="universal-quantifiers"></a>
### Universal Quantifier

```scala
scala> e"forall x: Int. x > 0"
res17: inox.trees.Expr = ∀x: Int. (x > 0)

scala> e"∀x. x || true"
res18: inox.trees.Expr = ∀x: Boolean. (x || true)
```

<a name="choose"></a>
## Choose

```scala
scala> e"choose x. x * 3 < 17"
res19: inox.trees.Expr = choose((x: BigInt) => x * 3 < 17)

scala> e"choose x: String. true"
res20: inox.trees.Expr = choose((x: String) => true)
```

<a name="primitives"></a>
# Primitives

<a name="primitive-strings"></a>
## Strings

### Literal Syntax

```
''
'hello world'
'hey!'
```

### Functions

| Function | Type | Description | Inox Constructor |
| -------- | ---- | ----------- | ---------------- |
| `length`   | `String => Integer` | Returns the length of the string. | `StringLength` |
| `concatenate` | `(String, String) => String` | Returns the concatenation of the two strings. | `StringConcat` |
| `substring` | `(String, Integer, Integer) => String` | Returns the substring from the first index inclusive to the second index exclusive. | `SubString ` |

### Operators

| Operator | Type | Associativity | Precedence | Description | Inox Constructor |
| -------- | ---- | ------------- | ---------- | ----------- | ---------------- |
| `++` | `(String, String) => String` | Left-associative | ??? | Returns the concatenation of the two strings. | `StringConcat` |

<a name="primitive-sets"></a>
## Sets

### Constructor

| Constructor | Description | Inox Constructor |
| ----------- | ----------- | ---------------- |
| `Set[A](elements: A*)` | Returns a set containing the given `elements`. | `FiniteSet` |

### Functions

| Function | Type | Description | Inox Constructor |
| -------- | ---- | ----------- | ---------------- |
| `contains[A]` | `(Set[A], A) => Boolean` | Returns `true` if the given set contains the given element, `false` otherwise. | `ElementOfSet` |
| `add[A]` | `(Set[A], A) => Set[A]` | Returns the set with an element added. | `SetAdd` |
| `subset[A]` | `(Set[A], Set[A]) => Boolean` | Returns `true` if the first set is a subset of the second, `false` otherwise. | `SubsetOf` |
| `union[A]` | `(Set[A], Set[A]) => Set[A]` | Returns the unions of the two sets. | `SetUnion` |
| `intersection[A]` | `(Set[A], Set[A]) => Set[A]` | Returns the intersection of the two sets. | `SetIntersection` |
| `difference[A]` | `(Set[A], Set[A]) => Set[A]` | Returns the elements of the first set minus the elements of the second set. | `SetDifference` |

### Operators

| Operator | Type | Associativity | Precedence | Description | Inox Constructor |
| -------- | ---- | ------------- | ---------- | ----------- | ---------------- |
| `∈` | `(A, Set[A]) => Boolean` | Left-associative | ??? | Returns `true` if the element is part of the set, `false` otherwise. | `ElementOfSet` |
| `⊆` | `(Set[A], Set[A]) => Boolean` | Left-associative | ??? | Returns `true` if the first set is a subset of the second, `false` otherwise. | `SubsetOf` | |
| `∪` | `(A, Set[A]) => Boolean` | Left-associative | ??? | Returns the unions of the two sets. | `SetUnion` |
| `∩` | `(A, Set[A]) => Boolean` | Left-associative | ??? | Returns the intersection of the two sets. | `SetIntersection` |
| `∖` | `(A, Set[A]) => Boolean` | Left-associative | ??? | Returns the elements of the first set minus the elements of the second set. | `SetDifference` |

<a name="primitive-bags"></a>
## Bags

### Constructor

| Constructor | Description | Inox Constructor |
| ----------- | ----------- | ---------------- |
| `Bag[A](bindings: (A -> Integer)*)` | Returns a bag containing the given `bindings`. | `FiniteBag` |

### Functions

| Function | Type | Description | Inox Constructor |
| -------- | ---- | ----------- | ---------------- |
| `multiplicity[A]` | `(Bag[A], A) => Integer` | Returns the number of occurrences in the given bag of the given value. | `MultiplicityInBag` |
| `bagAdd[A]` | `(Bag[A], A) => Bag[A]` | Returns the bag with an element added. | `BagAdd` |
| `bagUnion[A]` | `(Bag[A], Bag[A]) => Bag[A]` | Returns the unions of the two bags. | `BagUnion` |
| `bagIntersection[A]` | `(Bag[A], Bag[A]) => Bag[A]` | Returns the intersection of the two bags. | `BagIntersection` |
| `bagDifference[A]` | `(Bag[A], Bag[A]) => Bag[A]` | Returns the elements of the first bag minus the elements of the second bag. | `BagDifference` |

<a name="primitive-maps"></a>
## Maps

### Constructor

| Constructor | Description | Inox Constructor |
| ----------- | ----------- | ---------------- |
| `Map[A](default: A, bindings: (A -> Integer)*)` | Returns a map with default value `default` containing the given `bindings`. | `FiniteMap` |

### Functions

| Function | Type | Description | Inox Constructor |
| -------- | ---- | ----------- | ---------------- |
| `apply[K, V]` | `(Map[K, V], K) => V` | Returns the value associated to the given key. | `MapApply` |
| `updated[K, V]` | `(Map[K, V], K, V) => Map[K, V]` | Returns the map with a bidding from the key to the value added. | `MapUpdated` |
